\section{Shared Dependencies}

This is the section that outlines external and out-of-memory dependencies that the project will have.

 As it stands, this project is shared dependency heavy.

 Since I will follow the classical approach to TDD, I need to know these "shared" dependencies so that my unit tests can mock these out.


Below are results of learning how to import external libraries and linux packages into the project. 


\begin{itemize}
	\item NOTES:
	\begin{itemize}
		\item You can include C++ dependencies (libraries) in your project through clickable.
		\item From what I currently understand, Clickable can compile ARM software into desktop architecture as it uses a container. It may not be able to go the other way \(x86 / x86\_64 -> ARM\)
		\item Interestingly, it can run the app in a continuous integration environment due to the use of the ARM -> Desktop container. There are guides on how to do CLCI
		\item The consensus on Quora seems to be that the difficulty will range from: rebuilding with an ARM compiler to rewriting from scratch. It all depends on the type of software
	\end{itemize}
\end{itemize}



\begin{itemize}
	\item Links
	\begin{itemize}
		\item https://docs.ubports.com/en/latest/appdev/guides/dependencies.html
		\item https://ubports.com/blog/ubports-news-1/post/introduction-to-clickable-147
		\item https://clickable.bhdouglass.com/en/latest/
		\item https://www.quora.com/How-hard-is-it-to-port-an-application-from-x86-to-ARM
	\end{itemize}
\end{itemize}



TODO: Create a small list of external dependency candidates for each function in your proposed app. Favor dependencies that: already have an ARM build, that fit within your license model, is a C++ library, and requires the least amount of work to adapt.

TODO: Once the candidate list has been created, create a prototype project in which you try to import each dependency and use them one by one. Write down results for the results of each.



Contains the largest list of open source audio software that I could find. 

Look under "Software Development Libraries \& APIs":

https://github.com/webprofusion/OpenAudio

%\begin{tabular}{|l|l|l|l|l|l|l|}
\begin{tabular}{|p{2.25cm}|p{2.25cm}|p{2.25cm}|p{2.25cm}|p{2.25cm}|p{2.25cm}|p{2.25cm}|}
\hline
\thead{Name} & \thead{Brief Description} & \thead{License Type} & \thead{ARM Build} & \thead{C++ library} & \thead{Estimated work} & \thead{Link} \\ 
                    \hline
Avendish & C++20 framework for any sort of audio \/ video \/ midi media objects & GPLv3+ commercial & Not sure & Y & Too much, it's too general & https://celtera.github.io/avendish/ \\    \hline

DISTRHO  & C++ framework for creating cross-platform audio plugins. DPF can build for LADSPA, DSSI, LV2, and VST formats. & ISC License & Most likely, seems to be mostly native code & Y & Might be a lot, doesn't hold your hand & https://github.com/DISTRHO/DPF \\    \hline

Faust & Functional programming language for real-time signal processing & GNU General Public License v2.0 & Y, doesn't depend on external libraries so compile the generated code into ARM & Y, after generating the code & May require knowing the full extend of code functionality. That may hamper scalability, and create software design compromises. & https://faust.grame.fr/ \\    \hline


iPlug2 & b & c & d & e & f & g \\    \hline

JUCE & b & c & d & e & f & g \\    \hline

RustAudio & b & c & d & e & f & g \\    \hline

rtaudio & b & c & d & e & f & g \\    \hline

Traction Engine & b & c & d & e & f & g \\    \hline


    \end{tabular}